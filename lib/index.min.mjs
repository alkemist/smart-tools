var e=[,(e,t,r)=>{r.r(t),r.d(t,{ArrayHelper:()=>s.ArrayHelper,DateHelper:()=>a.DateHelper,MathHelper:()=>i.MathHelper,ObjectHelper:()=>p.ObjectHelper,StringHelper:()=>n.StringHelper,TreeHelper:()=>l.TreeHelper,TypeHelper:()=>y.TypeHelper});var s=r(2),a=r(3),i=r(4),p=r(7),n=r(6),l=r(11),y=r(5)},(e,t,r)=>{r.r(t),r.d(t,{ArrayHelper:()=>s});class s{}},(e,t,r)=>{r.r(t),r.d(t,{DateHelper:()=>s});class s{}},(e,t,r)=>{r.r(t),r.d(t,{MathHelper:()=>a});var s=r(5);class a{static parseInt(e){return s.TypeHelper.isNumber(e)?e:parseInt(e)}}},(e,t,r)=>{r.r(t),r.d(t,{TypeHelper:()=>l});var s=r(6),a=r(7),i=r(11),p=r(12),n=r(8);class l{static isEvaluable(e){return null!=e}static getPrototypeOf(e){return Object.getPrototypeOf(e)??{}}static isBoolean(e){return l.isEvaluable(e)&&("boolean"==typeof e||l.getPrototypeOf(e).constructor===Boolean)}static isKey(e){return l.isEvaluable(e)&&(l.isNumber(e)||l.isString(e))}static isNumber(e){return l.isEvaluable(e)&&("number"==typeof e||l.getPrototypeOf(e).constructor===Number)&&!isNaN(+s.StringHelper.stringify(e))}static isSymbol(e){return l.isEvaluable(e)&&("symbol"==typeof e||l.getPrototypeOf(e).constructor===Symbol)}static isString(e){return l.isEvaluable(e)&&("string"==typeof e||l.getPrototypeOf(e).constructor===String)}static isArray(e){return l.isEvaluable(e)&&Array.isArray(e)}static isRecord(e){return l.isEvaluable(e)&&"object"==typeof e&&"Object"===l.getPrototypeOf(e).constructor.name}static isObject(e){return l.isEvaluable(e)&&"object"==typeof e&&-1===[...n.PrimitiveClassNames,"Array","Object"].indexOf(l.getPrototypeOf(e).constructor.name)}static isTree(e){return l.isArray(e)||a.ObjectHelper.hasStringIndex(e)}static isFunction(e){return l.isEvaluable(e)&&("function"==typeof e||e instanceof Function||"[object Function]"===s.StringHelper.stringify(e))}static isDate(e){return l.isObject(e)&&"Date"===l.getPrototypeOf(e).constructor.name}static isT(e){return e}static isPrimitive(e){return l.isEvaluable(e)&&!l.isTree(e)&&!l.isFunction(e)}static isEqual(e,t){const r=new p.TypeState(e);let s=new p.TypeState(t);const a=Object.is(l.serialize(e),l.serialize(t));if(a){const a=Object.is(r.type,s.type);return a&&r.isObject&&s.isObject?Object.is(l.getPrototypeOf(e),l.getPrototypeOf(t)):a}return a}static serialize(e){const t=i.TreeHelper.flat(e);return l.isString(t)?t:JSON.stringify(t)}static deepClone(e){if(l.isArray(e))return e.map((e=>l.deepClone(e)));if(l.isDate(e))return new Date(e);if(a.ObjectHelper.hasStringIndex(e)){const t=i.TreeHelper.getCycles(e),r=l.getPrototypeOf(e);return i.TreeHelper.keys(e).filter((e=>-1===t.indexOf(e))).reduce(((t,r)=>{const s=Object.getOwnPropertyDescriptor(e,r);return void 0!==s&&Object.defineProperty(t,r,s),t[r]=l.deepClone(e[r]),t}),r?Object.create(r):{})}return e}}},(e,t,r)=>{r.r(t),r.d(t,{StringHelper:()=>a});var s=r(5);class a{static stringify(e){return s.TypeHelper.isEvaluable(e)?void 0!==typeof e.toString||s.TypeHelper.isSymbol(e)?e.toString():e+"":null===e?"null":"undefined"}}},(e,t,r)=>{r.r(t),r.d(t,{ObjectHelper:()=>i});var s=r(5),a=r(8);class i{static hasStringIndex(e){return s.TypeHelper.isEvaluable(e)&&"object"==typeof e&&-1===[...a.PrimitiveClassNames,"Array"].indexOf(s.TypeHelper.getPrototypeOf(e).constructor.name)}}},(e,t,r)=>{r.r(t),r.d(t,{PrimitiveClassNames:()=>s.PrimitiveClassNames});var s=r(9);r(10)},(e,t,r)=>{r.r(t),r.d(t,{PrimitiveClassNames:()=>s});const s=["Boolean","Number","String"]},(e,t,r)=>{r.r(t)},(e,t,r)=>{r.r(t),r.d(t,{TreeHelper:()=>l});var s=r(12),a=r(7),i=r(4),p=r(5),n=r(6);class l{static keys(e){return p.TypeHelper.isEvaluable(e)?p.TypeHelper.isArray(e)?Object.keys(e).map((e=>parseInt(e))):Object.getOwnPropertyNames(e):[]}static getIn(e,t){let r=e,s=0;if(r)for(;s<t.length;){const e=t[s];r=a.ObjectHelper.hasStringIndex(r)?r[e]:p.TypeHelper.isArray(r)?r[i.MathHelper.parseInt(e)]:void 0,s++}return r}static hasProperty(e,t){if(p.TypeHelper.isKey(t)&&(t=[t]),0===t.length)return!0;if(!p.TypeHelper.isEvaluable(e)||!p.TypeHelper.isTree(e))return!1;let r=t[0];if(1===t.length)return l.hasOwn(e,r);if(!l.hasOwn(e,r))return!1;const s=(p.TypeHelper.isNumber(r),e[r]);return!!p.TypeHelper.isTree(s)&&l.hasProperty(s,t.slice(1))}static hasOwn(e,t){return p.TypeHelper.isArray(e)&&p.TypeHelper.isNumber(t)?t<e.length:Object.hasOwn(e,t)}static flat(e){const t=new s.TypeState(e);if(!t.isValuable||t.isPrimitive||t.isFunction)return p.TypeHelper.isString(e)?`"${e}"`:n.StringHelper.stringify(e);if(p.TypeHelper.isDate(e))return e;if(p.TypeHelper.isTree(e)){const r=t.isArray?[]:{};return l.keys(e).forEach((t=>{p.TypeHelper.isArray(e)?r[t]=l.flat(e[i.MathHelper.parseInt(t)]):a.ObjectHelper.hasStringIndex(e)&&(r[t]=l.flat(e[t]))})),r}return e}static getCycles(e){if(!p.TypeHelper.isEvaluable(e))return[];const t=new Set,r=[],a=function(e,n=new s.Path){t.has(e)?r.push(n):(t.add(e),l.keys(e).forEach((t=>{const r=n.clone();r.push(t);const s=p.TypeHelper.isArray(e)?e[i.MathHelper.parseInt(t)]:e[t];p.TypeHelper.isTree(s)&&a(s,r)})))};return a(e),r.map((e=>e.toString()))}}},(e,t,r)=>{r.r(t),r.d(t,{Path:()=>s.Path,SmartMap:()=>a.SmartMap,TypeState:()=>i.TypeState,TypeStateEnum:()=>i.TypeStateEnum});var s=r(13),a=r(14),i=r(15)},(e,t,r)=>{r.r(t),r.d(t,{Path:()=>a});var s=r(1);class a extends Array{add(e){return super.push(e),this}clone(){return this.slice()}slice(e,t){const r=new a;return r.push(...super.slice(e,t)),r}toString(){return this.reduce(((e,t)=>e+(s.TypeHelper.isNumber(t)?`[${t}]`:`${""===e?"":"."}${t}`)),"")}last(){return this.length>0?this[this.length-1]:void 0}}},(e,t,r)=>{r.r(t),r.d(t,{SmartMap:()=>s});class s extends Map{_keys=[];_values=[];constructor(e=[]){super(e),this._keys=e.map((e=>e[0])),this._values=e.map((e=>e[1]))}get(e){return super.get(e)}set(e,t){if(this.has(e)){const r=this._keys.indexOf(e);this._values[r]=t}else this._keys.push(e),this._values.push(t);return super.set(e,t),this}getKeys(){return this._keys}getValues(){return this._values}map(e){return this._keys.map(((t,r)=>e(this._values[r],t,r)))}each(e){this._keys.forEach(((t,r)=>{e(this._values[r],t,r)}))}find(e){return this._values.find(((t,r)=>e(t,this._keys[r],r)))}filter(e){const t=new s;return this._keys.filter(((t,r)=>e(this._values[r],t,r))).forEach((e=>t.set(e,this.get(e)))),t}}},(e,t,r)=>{r.r(t),r.d(t,{TypeState:()=>i,TypeStateEnum:()=>s});var s,a=r(1);!function(e){e.NO_EVALUABLE="no_evaluable",e.PRIMITIVE="primitive",e.OBJECT="object",e.RECORD="record",e.ARRAY="array",e.FUNCTION="function"}(s||(s={}));class i{_type;constructor(e){null==e?this._type=s.NO_EVALUABLE:a.TypeHelper.isArray(e)?this._type=s.ARRAY:a.TypeHelper.isRecord(e)?this._type=s.RECORD:a.TypeHelper.isObject(e)?this._type=s.OBJECT:a.TypeHelper.isFunction(e)?this._type=s.FUNCTION:this._type=s.PRIMITIVE}get type(){return this._type}get isValuable(){return this._type!==s.NO_EVALUABLE}get isPrimitive(){return this._type===s.PRIMITIVE}get isArray(){return this._type===s.ARRAY}get isObject(){return this._type===s.OBJECT}get isRecord(){return this._type===s.RECORD}get isFunction(){return this._type===s.FUNCTION}}}],t={};function r(s){var a=t[s];if(void 0!==a)return a.exports;var i=t[s]={exports:{}};return e[s](i,i.exports,r),i.exports}r.d=(e,t)=>{for(var s in t)r.o(t,s)&&!r.o(e,s)&&Object.defineProperty(e,s,{enumerable:!0,get:t[s]})},r.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),r.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})};var s={};(()=>{r.r(s),r.d(s,{ArrayHelper:()=>e.ArrayHelper,DateHelper:()=>e.DateHelper,MathHelper:()=>e.MathHelper,ObjectHelper:()=>e.ObjectHelper,Path:()=>a.Path,PrimitiveClassNames:()=>t.PrimitiveClassNames,SmartMap:()=>a.SmartMap,StringHelper:()=>e.StringHelper,TreeHelper:()=>e.TreeHelper,TypeHelper:()=>e.TypeHelper,TypeState:()=>a.TypeState,TypeStateEnum:()=>a.TypeStateEnum});var e=r(1),t=r(8),a=r(12)})();var a=s.ArrayHelper,i=s.DateHelper,p=s.MathHelper,n=s.ObjectHelper,l=s.Path,y=s.PrimitiveClassNames,o=s.SmartMap,u=s.StringHelper,c=s.TreeHelper,H=s.TypeHelper,h=s.TypeState,T=s.TypeStateEnum;export{a as ArrayHelper,i as DateHelper,p as MathHelper,n as ObjectHelper,l as Path,y as PrimitiveClassNames,o as SmartMap,u as StringHelper,c as TreeHelper,H as TypeHelper,h as TypeState,T as TypeStateEnum};